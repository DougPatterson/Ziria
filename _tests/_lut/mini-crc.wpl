
-- TODO: Really, the code below should be using LUTs, generated by the compiler
-- from some nice description of the CRC shift register.  Bozidar says we will
-- need to do this to get reasonable performance.

var base: arr[4] int;
var crc_state: arr[4] int;

let emit_arr(a: arr[4] int) =
  emit a[0]; emit a[1]; emit a[2]; emit a[3]
in

let len = 4 in

let xorA(ar: arr[4] int, a1: arr[4] int, a2: arr[4] int) =
  for k,v in a1 {
    ar[k] := a1[k]^a2[k]
  }
in

let shiftl(a: arr[4] int) =
  for k,v in a {
    if k < 3 { a[k] := a[k+1] }
    else { a[k] := 0 }
  }
in

let update_crc(x:int) =
  if crc_state[0] == 1 {
    xorA(crc_state, crc_state, base)
  } else { 
    tt 
  };
  shiftl(crc_state);
  crc_state[len-1] := x
in

let crc =  
  return (
    -- TODO: Add support for array literals so init. can be done statically
    base[0] := 1; base[1] := 0; base[2] := 1; base[3] := 1
  );
  repeat (
    x <- take1;
    return (update_crc(x));
    emit_arr(crc_state)
  )  
in



read >>> crc >>> write
