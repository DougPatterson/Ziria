Fixed point arithmetics:

All double types should have precision in the declaration, e.g.
    var d : double (3,28)
    var f : double (5,10)
Here, d is a 32-bit number with 1 sign bit, 3 integer bits and 32-1-3 = 28 fractional bits.
f is a 16-bit number with 1 sign bit, 5 integer bits and 16-1-5 = 10 fractional bits. 
Note that the width of the numbers could be arbitrary, which makes sense in FPGAs. 

It is easy to further derive code generation for simple operations. For example
  var f1 : double (i,k);
  var f2 : double (j,l);
  f = f1 + f2  ===(should compile into)===>   f = if (i>j) {f1>>1 + (f2 >> (i-j+1))} else {(f1 >> (j-i+1)) + f2>>1}
  where f : double(max(i,j)+1, ...too lazy to calculate :)...) 
and +1 is to make sure we don't loose precision in case of overflow.
Similar rules can be derived for other operations (c.f. http://digitalsignallabs.com/fp.pdf)
Also, in this case we ideally want to have 
  var f : double (k, ...too lazy to calculate :)...), where k = max(i,j)+1
However, it is easy to extend the example to adjust the output expression
to an arbitrary k, with possible loss of precision


We can extend this to more complicated expression. Consider
    var f:double(k,l);
    var x,y,z:double(i,j)
    f = x + (y*z)

Then, y*z : double(2*i+1,...), x + (y*z) : double(2*i+2,...) and then we store it in f 
by shifting appropriately (with a possible loss of precision). 


All the above requires programmers to annotate the types. 
However, a programmer should ideally only annotate the variables it cares about. 
For example, in cca code, it should annotate the input variables, and the final thresholds it cares about.
The rest of precision should be infered by the compiler. 

Q: Is it intuitively clear to the programmer how to set up the thresholds? 
We should try on an example. 



*** Some related work:
Fixed point extension for C for embedded processors: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1169.pdf
      Related gcc support: http://gcc.gnu.org/wiki/FixedPointArithmetic

Anything on the compiler side? I imagine someone has looked into this over years...
